{"paragraphs":[{"text":"%md\n<div class=\"alert alert-warning\" role=\"alert\" style=\"margin: 10px\">\n<h3>Aspect Based Sentiment Analysis on Food Review Dataset</h3>\n<h4>Components Used</h4>\n* Spark version 1.6.1 for Hadoop 2.6</br>\n* Zeppelin version 0.6.0 with `SPARK_HOME` set to Spark 1.6.1 for Hadoop 2.6</br>\n* PHEMI Data Source Library 1.1</br>\n* PHEMI Zeppelin Library 1.0</br>\n* Stanford CoreNLP 3.8.0</br>\n</div>\n\n<div class=\"clearfix\" style=\"padding: 10px; padding-left: 0px\">\n<a href=\"http://www.phemi.com\"><img src=\"http://phemi.com/wp-content/uploads/2014/11/PHEMI-logo.png\" width=\"150px\" class=\"pull-left\" style=\"display: inline-block; margin: 0px;\"></a>\n</div>","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177483_-1373877803","id":"20170817-171806_1700861632","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16209"},{"title":"Load Data Collection","text":"import com.phemi.zeppelin.ZeppelinPhemiCredentials\nimport com.phemi.spark.PhemiSparkLib\nimport org.apache.spark.sql.functions.lit\nval cred = new ZeppelinPhemiCredentials(z.getInterpreterContext())\nval psl = new PhemiSparkLib(cred, sqlContext)\n\nvar df1 = psl.loadPhemiDataCollection(\"Aspect Based Food Reviews\").cache()\nz.show(df1)","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":true,"keys":[{"name":"aspects","index":0,"aggr":"sum"}],"values":[{"name":"aspects","index":0,"aggr":"count"}],"groups":[],"scatter":{"xAxis":{"name":"aspects","index":0,"aggr":"sum"},"yAxis":{"name":"categories","index":1,"aggr":"sum"}}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177483_-1373877803","id":"20170817-164102_1830385222","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16210"},{"text":"df1.count()","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177491_-1364643830","id":"20170817-183056_1484484721","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16211"},{"title":"Pre-Process Dataset","text":"import scala.util.Try\nimport org.apache.spark.sql.functions.{udf, explode}\n\n// zip the columns$\"text\"\nval zip1 = udf((xs: Seq[String], ys: Seq[String]) => xs.zip(ys))\n\n// zip and explode\nvar dfMain = df1.withColumn(\"split\", explode(zip1(split($\"aspects\",\",\"), split($\"sentiments\",\",\")))).select($\"split._1\".alias(\"aspect\"), $\"split._2\".alias(\"sentiment\"), $\"text\").where(!$\"sentiment\".contains(\"conflict\")).cache()\nz.show(dfMain)","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[{"name":"aspect","index":0,"aggr":"sum"}],"values":[{"name":"sentiment","index":1,"aggr":"sum"}],"groups":[],"scatter":{"xAxis":{"name":"aspect","index":0,"aggr":"sum"},"yAxis":{"name":"sentiment","index":1,"aggr":"sum"}}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177492_-1366567574","id":"20170817-171004_1192293308","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16212"},{"title":"Group By","text":"dfMain.count()\ndfMain.groupBy(\"aspect\").count().orderBy($\"count\".desc).show()","dateUpdated":"2017-08-28T22:09:37+0000","config":{"tableHide":true,"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177500_-1369645565","id":"20170817-183117_1170243541","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16213"},{"text":"dfMain = dfMain.where(\"aspect in ('food', 'service', 'place', 'price')\")\nz.show(dfMain)","dateUpdated":"2017-08-28T22:09:37+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"graph":{"mode":"multiBarChart","height":300,"optionOpen":false,"keys":[{"name":"aspect","index":0,"aggr":"sum"}],"values":[{"name":"aspect","index":0,"aggr":"count"}],"groups":[],"scatter":{"xAxis":{"name":"aspect","index":0,"aggr":"sum"},"yAxis":{"name":"sentiment","index":1,"aggr":"sum"}}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177500_-1369645565","id":"20170817-183131_955515098","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16214"},{"title":"Define CoreNLP Functions","text":"import scala.collection.mutable._\nimport math._\n\n// get sentiment for label and entire string\n  def getSentimentForLabel(line: String, aspect: String): (ListBuffer[Int], ListBuffer[Double] ,ListBuffer[Int], ListBuffer[Double]) = {\n      \n    import java.util.Properties\n    import edu.stanford.nlp.ling.CoreAnnotations\n    import edu.stanford.nlp.neural.rnn.RNNCoreAnnotations\n    import edu.stanford.nlp.pipeline.Annotation\n    import edu.stanford.nlp.pipeline.StanfordCoreNLP\n    import edu.stanford.nlp.sentiment.SentimentCoreAnnotations\n    import edu.stanford.nlp.trees.Tree\n    import edu.stanford.nlp.util.CoreMap\n    import scala.util.control._\n    import scala.collection.JavaConversions._\n    import util.control.Breaks._\n    import edu.stanford.nlp.ling._\n    import scala.collection.mutable._\n    import org.apache.spark.sql.functions.udf\n\n    val lstMainSentiment = scala.collection.mutable.ListBuffer.empty[Int]\n    val lstMainScore = scala.collection.mutable.ListBuffer.empty[Double]\n    val lstAspectSentiment = scala.collection.mutable.ListBuffer.empty[Int]\n    val lstAspectScore = scala.collection.mutable.ListBuffer.empty[Double]\n    \n    val props = new Properties();\n    props.setProperty(\"annotators\", \"tokenize, ssplit, parse, sentiment\");\n    val nlp = new StanfordCoreNLP(props);\n    \n    if (line != null && line.length > 0) {\n      val annotation = nlp.process(line)\n\n      //breakable {\n        // loop through every sentence\n        for (sentence <- annotation.get(classOf[CoreAnnotations.SentencesAnnotation])) {\n\n          // get root tree, its sentiment and score\n          val tree = sentence.get(classOf[SentimentCoreAnnotations.SentimentAnnotatedTree])\n          var mainSentiment = RNNCoreAnnotations.getPredictedClass(tree);\n          lstMainSentiment += mainSentiment;\n          lstMainScore  += tree.label().asInstanceOf[edu.stanford.nlp.ling.CoreLabel].get(classOf[RNNCoreAnnotations.Predictions]).get(mainSentiment);\n\n          // set variables\n          var aspectScore = -1.0; // negative if aspect not found\n          var aspectIndex = 0 // starting index to find aspect\n          var minSentiment = 2  // neutral\n\n          // get all leaf nodes\n          val leaves = tree.getLeaves()\n          //println(leaves)\n\n          breakable {\n\n            // loop through leaf nodes\n            for (leave <- leaves.toArray) {\n\n              // check if leaf node matches aspect\n              if (leave.toString().equalsIgnoreCase(aspect)) {\n\n                // get tree of aspect\n                var aspectTree: edu.stanford.nlp.trees.LabeledScoredTreeNode = tree.getLeaves()(aspectIndex)\n\n                // loop through every parent of aspect until we find a non-neutral node\n                while (!aspectTree.label().toString().equalsIgnoreCase(\"ROOT\") && minSentiment == 2) {\n\n                  // reset aspect score\n                  aspectScore = 0.2\n\n                  // get parent\n                  aspectTree = aspectTree.parent(tree).asInstanceOf[edu.stanford.nlp.trees.LabeledScoredTreeNode];\n\n                  // get matrix of scores\n                  val leafNodeSentimentMatrix = aspectTree.label().asInstanceOf[edu.stanford.nlp.ling.CoreLabel].get(classOf[RNNCoreAnnotations.Predictions])\n\n                  // set aspect score and index to the max value in matrix\n                  for (index <- 0 until 5) {\n                    if (aspectScore < leafNodeSentimentMatrix.get(index)) {\n                      aspectScore = leafNodeSentimentMatrix.get(index)\n                      minSentiment = index\n                    }\n                  }\n                }\n\n                // break from inner loop if aspect is found\n                break;\n              }\n              // move to next leaf node\n              aspectIndex = aspectIndex + 1\n            }\n          }\n\n          // set final aspect sentiment\n          lstAspectSentiment += minSentiment\n          lstAspectScore += aspectScore\n        }\n    }\n\n    // return values\n    (lstMainSentiment, lstMainScore, lstAspectSentiment, lstAspectScore);\n  }\n\n// return sentiment for sentiment score\ndef getSentimentString(sentiment: Double): String = {\n    \n    var value = sentiment \n    \n    // there is alteast one negative sentiment\n    if (sentiment < 2.0)\n    {\n        value = floor(sentiment)\n    }\n    \n    // there is alteast one postive sentiment\n    if (sentiment > 2.0)\n    {\n        value = ceil(sentiment)\n    }\n    \n    value.toInt match\n    {\n        case 0 => \"negative\"\n        case 1 => \"negative\"\n        case 2 => \"neutral\"\n        case 3 => \"positive\"\n        case 4 => \"positive\"\n    }\n}\n\n// get sentiment for the entire row\ndef getOverallSentiment(line: String): String = {\n    \n   val (lstMainSentiment, lstMainScore, lstAspectSentiment, lstAspectScore) = getSentimentForLabel(line, \"\")\n   \n   var sentiment = 0.0\n   \n   // for each sentence is the row of sentences, get sentiment on sentence (0, 1, 2, 3, 4)\n   for (s <- lstMainSentiment)\n   {\n       sentiment = sentiment + s\n   }\n   \n   // average the sentiment to get the overall sentiment on the row\n   sentiment = sentiment/lstMainSentiment.length\n   println(sentiment)\n   getSentimentString(sentiment)\n}\n\n\n// get sentiment score for the entire row\ndef getOverallScore(line: String): Double = {\n    \n   val (lstMainSentiment, lstMainScore, lstAspectSentiment, lstAspectScore) = getSentimentForLabel(line, \"\")\n   \n   var score = 0.0\n   \n   // for each sentence is the row of sentences, get score\n   for (s <- lstMainScore)\n   {\n       score = score + s\n   }\n   \n   // average the score to get the overall score on the row. The sentiment for this score is given by method getOverallSentiment\n   score = score/lstMainScore.length\n   return score\n}\n\n// get sentiment for an aspec in the entire row\ndef getAspectSentiment(line: String, aspect: String): String = {\n   \n   // getSentimentForLabel returns -1 if the apect is not present in the sentence \n   val (lstMainSentiment, lstMainScore, lstAspectSentiment, lstAspectScore) = getSentimentForLabel(line, aspect)\n   \n   var sentiment = 0.0\n   var aspectOccuranceCount = 0\n   \n   for ((s, j) <- lstAspectSentiment zip lstAspectScore)\n   {\n       // only add if sentiment is present (non negative value for score)\n       if(j != -1.0)\n       {\n           sentiment = sentiment + s\n           aspectOccuranceCount = aspectOccuranceCount + 1\n       }\n   }\n   \n   // return the sentiment if aspect occur else return \"aspect not found\"\n   if(aspectOccuranceCount != 0)\n   {\n        sentiment = sentiment/aspectOccuranceCount\n        return getSentimentString(sentiment)\n   }else\n   {\n       return \"aspect not found\"\n   }\n}\n\ndef getAspectScore(line: String, aspect: String): Double = {\n\n   // getSentimentForLabel returns -1 if the apect is not present in the sentence    \n   val (lstMainSentiment, lstMainScore, lstAspectSentiment, lstAspectScore) = getSentimentForLabel(line, aspect)\n   \n   var score = 0.0\n   var aspectOccuranceCount = 0\n   \n   for (s <- lstAspectScore)\n   {\n        // only add if sentiment is present\n        if(s != -1.0)\n        {\n            score = score + s\n            aspectOccuranceCount = aspectOccuranceCount + 1\n       }\n   }\n   \n    // return the score if aspect occur. Zero aspect socre means aspect is not present in the row.\n    if(aspectOccuranceCount != 0)\n    {\n        score = score/aspectOccuranceCount\n        return score\n    }else\n    {\n        return 0.0\n    }\n}\n\n// udf to get aspect sentiment to get aspe\nval udfAspectBasedSentiment = udf(getAspectSentiment(_:String, _:String))","dateUpdated":"2017-08-28T22:09:37+0000","config":{"tableHide":true,"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177501_-1370030314","id":"20170816-175839_871718980","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16215"},{"text":"val input = z.input(\"Enter Aspect\")\nz.run(\"20170816-162811_444399728\")\nz.run(\"20170817-185911_1303974319\")","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{"Enter Aspect":"service","aspect":"food"},"forms":{"Enter Aspect":{"name":"Enter Aspect","displayName":"Enter Aspect","type":"input","defaultValue":"","hidden":false}}},"jobName":"paragraph_1503958177501_-1370030314","id":"20170817-193615_189059607","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16216"},{"title":"Get Model Accuracy","text":"val aspect = input\nval dfFood = dfMain.filter(col(\"aspect\").isin(aspect))\nval dfFinal = dfFood.withColumn(\"predicted_sentiment\", udfAspectBasedSentiment(dfFood(\"text\"), lit(aspect))).cache\n\nval count_true = dfFinal.filter(\"predicted_sentiment = sentiment\").count()\nval count_false = dfFinal.filter(\"predicted_sentiment != sentiment\").count()\n\nval accuracy = 1.0*count_true/(count_true + count_false)\nprintln(\"%html <h4> Accuracy = \" + accuracy + \"</h4>\")","dateUpdated":"2017-08-28T22:09:52+0000","config":{"tableHide":false,"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177501_-1370030314","id":"20170816-162811_444399728","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16217"},{"title":"Aspect Sentiment","text":"z.show(dfFinal)","dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"title":true,"graph":{"mode":"pieChart","height":300,"optionOpen":false,"keys":[{"name":"sentiment","index":1,"aggr":"sum"}],"values":[{"name":"sentiment","index":1,"aggr":"count"}],"groups":[],"scatter":{"xAxis":{"name":"aspect","index":0,"aggr":"sum"},"yAxis":{"name":"sentiment","index":1,"aggr":"sum"}}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177501_-1370030314","id":"20170817-185911_1303974319","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16218"},{"dateUpdated":"2017-08-28T22:09:37+0000","config":{"colWidth":12,"editorMode":"ace/mode/scala","editorHide":true,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1503958177502_-1368876068","id":"20170816-222546_637440286","dateCreated":"2017-08-28T22:09:37+0000","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:16219"}],"name":"Aspect Based Sentiment Analysis - Food Review","id":"2CUNZ412W","angularObjects":{"2CSK4631B:shared_process":[],"2CQECCVSU:shared_process":[],"2CR848DW4:shared_process":[],"2CQP88XBU:shared_process":[],"2CQTGB6U5:shared_process":[],"2CS3BY5RH:shared_process":[],"2CRF55T8Z:shared_process":[],"2CSS1T5JT:shared_process":[],"2CRYS1197:shared_process":[],"2CPY7XMQN:shared_process":[],"2CPUKP3QX:shared_process":[],"2CT9X7PFQ:shared_process":[],"2CT67D9MP:shared_process":[],"2CS3Y6AXN:shared_process":[],"2CRKSUPR1:shared_process":[],"2CSSV4ZJG:shared_process":[]},"config":{"looknfeel":"default"},"info":{}}